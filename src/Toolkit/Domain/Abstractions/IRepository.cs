namespace Toolkit.Domain.Abstractions
{
    /// <summary>
    /// Репозитории используются для сохранения и извлечения агрегатов, отделяя предметную модель от модели данных.
    /// Репозитории прячут за собой инфраструктурную сложность.
    /// 
    /// Репозитории позволяют извлекать и сохранять только корни агрегатов. Репозитории предоставляют только интерфейс,
    /// скрывающий детали сохранения и извлечения агрегатов. Репозитории являются границами между предметной моделью
    /// и моделью данных.
    /// 
    /// Интерфейс репозитория определяется в доменном слое, а реализация в инфраструктурном.
    /// 
    /// Репозиторий является дополнительной абстракцией, и если нужен простой доступ к данным, то такая прослойка скорее
    /// всего будет избыточной. Однако, когда мы моделируем сложную предметную область, шаблон репозиторий дополняет
    /// модель, помогает яснее выразить намерения за счет более явных названий методов и скрыть технические детали
    /// фреймворков.
    /// 
    /// Репозиторий позволяет выражать доступ к данным не в виде стандартных методов фреймворков (create, update, get)
    /// или sql запросов, а предоставляет понятные предметной модели названия методов. Репозиторий должен строиться
    /// исходя из сценариев использования приложений, а не CRUD операций.
    /// 
    /// Использовать обобщенные репозитории в общем смысле плохая практика, так как каждый агрегат обладает
    /// индивидуальностью и не каждому необходимы все методы обобщенного репозитория. Например, некоторые агрегаты могут
    /// быть только для чтения, а некоторые нельзя удалять и т.д.
    /// 
    /// Названия методов в репозитории должны именоваться также четко в соответствии с предметной областью как и
    /// названия предметных сущностей.
    /// 
    /// Не следует перегружать контракт репозитория лишними методами. (YAGNI)
    /// 
    /// Репозиторий также может выступать в качестве предохранительного слоя (anticorruption layer) для legacy кода.
    /// В данном случае репозиторий может преобразовывать сырые данные в сущности, которые будут выразительно отображены
    /// в нашей предметной модели.
    /// 
    /// Следует избегать в репозитории универсальных методов, которые позволяют получать произвольные ответы.
    /// Такие запросы будет сложно оптимизировать и контролировать. Лучше написать несколько специализированных методов,
    /// которые можно будет оптимизировать под фреймворк.
    /// 
    /// В репозитории не должно быть метода с IQueryable!
    /// В качестве компромисса, если нужен универсальный доступ к данных, например, для формирования отчетов, то лучше
    /// создать для этого отдельный репозиторий IEntityReportRepository и в него положить метод с IQueryable или
    /// какой-либо другой универсальный метод.
    /// </summary>
    /// <typeparam name="TAggregate"></typeparam>
    public interface IRepository<TAggregate> where TAggregate : Entity, IAggregateRoot
    {
        // не используем обобщенные методы!
    }
}
