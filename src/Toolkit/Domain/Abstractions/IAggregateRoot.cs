namespace Toolkit.Domain.Abstractions
{
    /// <summary>
    /// Модель предметной области - это не точное отображение всех взаимосвязей сложного реального мира, и более того,
    /// это не отображение модели данных лежащей в ее основе. Наиболее важная ее цель - это поддержка инвариантов и
    /// сценариев использования, а не пользовательских интерфейсов или хранилищ данных.
    /// 
    /// Если отношение между сущностями не является строго необходимым (не используется для удовлетворения инварианта),
    /// откажитесь от реализации такого отношения.
    /// 
    /// Создавайте простую однонаправленную модель, моделируйте исходя из сценариев использования, а не отражения
    /// реального мира. Упростив модель, вы обеспечите простоту ее реализации и последующее сопровождение.
    /// 
    /// Нужно стараться заменять все двунаправленные отношения однонаправленными, это сильно упрощает модель.
    /// 
    /// Агрегаты - объекты, содержащие в себе сущности и объекты-значения, основной задачей агрегатов является
    /// обеспечение границ согласованности. Агрегаты повышают эффективность и надежность системы.
    /// 
    /// Связь между агрегатами допустима только с помощью идентификаторов. Использовать ссылки допустимо только внутри
    /// агрегата для поддержки инвариантов и сценариев использования.
    /// 
    /// В модель нужно включать только связи, необходимые для поддержки инвариантов предметной области.
    /// 
    /// Агрегаты помогают разбить большое дерево взаимоотношений сущностей из реального мира на объекты небольших
    /// размеров, что уменьшает техническую сложность реализации и увеличивает ясность и понимание модели.
    /// 
    /// Агрегаты должны представлять предметные понятия.
    /// 
    /// Согласовывайте границы агрегатов с предметными инвариантами.
    /// 
    /// Агрегаты определяют границы согласованности и гарантируют безопасность состояния предметной модели.
    /// 
    /// Агрегаты обеспечивают проведение границ транзакций на правильном уровне детализации и помогают избежать
    /// блокировок.
    /// 
    /// Старайтесь создавать маленькие агрегаты, чтобы увеличить производительность и уменьшить кол-во блокировок.
    /// Но уменьшать размер агрегата только ради уменьшения, жертвуя выразительностью модели - это плохой подход.
    /// 
    /// Корень агрегата - это сущность, входящая в состав агрегата и играющая роль ворот в агрегат.
    /// Именно корень агрегата гарантирует и проверяет согласованность всех поддерживаемых инвариантов.
    /// 
    /// Корень агрегата обязан иметь глобальную индивидуальность. Сущности внутри агрегата не обязаны иметь глобальную
    /// индивидуальность. Предметные объекты за пределами агрегата могут ссылаться только на корень агрегата, но не
    /// могут на идентификаторы внутренних сущностей.
    /// 
    /// Когда удаляется корень агрегата, вместе с ним должны удаляться все элементы этого агрегата.
    /// 
    /// Корень агрегата может возвращать копии или ссылки на внутренние предметные объекты для использования в
    /// предметных операциях, но любые изменения должны производиться только через корень агрегата.
    /// 
    /// Агрегаты должны сохраняться в базе данных целиком и извлекаться также целиком.
    /// 
    /// Внутренние объекты агрегата могут хранить сслыки на корни других агрегатов, но только в виде идентификаторов.
    /// 
    /// В идеале границы транзакий должны совпадать с границами агрегатов. Но это правило не работает для создания
    /// агрегатов, так как при создании не могут возникать блокировки. И с другой стороны если действительно требуется
    /// транзакционная целостность между агрегатами, то допускается сохранять несколько агрегатов в одной транзакции.
    /// 
    /// Не нужно проектировать модель исходя из пользовательского интерфейса, нужно отображать в модели инварианты и
    /// сценарии использования.
    /// 
    /// Не нужно путать агрегаты с просто коллекцией или контейнером.
    /// 
    /// Не нужно зацикливаться на отношениях владения. Нужно стараться определять отношения между агрегатами, и если нет
    /// инварианта, который бы затрагивал две сущности, то скорее всего это разные агрегаты. И обратно, если сущности
    /// тесно связаны инвариантами, то это четкий признак, что эти сущности должны быть объединены в агрегат.
    /// 
    /// Не нужно бояться изменять границы агрегатов. Изменение агрегатов это вполне нормальный процесс, потому что
    /// добавление новых сценариев использования нашей системы так или иначе может привносить новые инварианты, и тогда
    /// придется пересмотреть наши агрегаты.
    /// 
    /// Еще раз главное - удовлетворить потребности сценариев использования, а не соответствие реальности, или
    /// пользовательскому интерфейсу, или хранению данных.
    /// 
    /// Крайне желательно экспортировать не состояние агрегата, а его поведение. Тут стоит рассмотреть возможность
    /// вообще скрывать геттеры.
    /// 
    /// Есть исключение, когда можно обращаться к сущностям внутри агрегата - отчеты.
    /// 
    /// Нужно избегать lazy loading. Он часто ведет к проблеме "n+1 requests" и в контексте DDD чаще является
    /// антипаттерном, нужны веские причины для использования ленивой загрузки, чаще всего касающиеся
    /// производительности. При правильном проектировании агрегатов, ленивая загрузка скорее всего не понадобится.
    /// 
    /// Агрегаты должны конструироваться на основе инвариантов и включать все свойства, необходимые для соответствия
    /// этим инвариантам. Поэтому агрегаты должны загружаться полностью, либо не загружаться вовсе.
    /// Если появляется такая возможность, что вы можете загрузить только часть агрегата, не нарушая
    /// инвариантов, то есть большая вероятность, что вы неверно определили границы агрегатов.
    /// Например, агрегат содержит большую коллекцию с ежедневными ценами на несколько лет и вы хотите загружать 
    /// эту коллекцию только по мере необходимости. В данном случае, вероятно, ежедневную цену следовало бы поместить
    /// в отдельный агрегат.
    /// 
    /// Если есть возможность сделать отложенную согласованность агрегатов, то лучше придерживаться именно такого
    /// подхода.
    /// 
    /// Для поддержки одновременного доступа нескольких пользователей к одному агрегату можно использовать
    /// версионирование агрегата.
    /// </summary>
    public interface IAggregateRoot
    {
    }
}
